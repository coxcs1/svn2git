#!/bin/bash
WEBPAGE_URL='http://{{ groups.all[0] }}'
IP_ADDRESS='{{ inventory_hostname }}'
TOKEN='{{ token }}'
INSTALL_DIR={{ install_dir }}
LOG_DIRECTORY={{ install_dir }}/logs
GIT_REPO_DIR='{{ git_repo_url }}'
SVN_USERNAME='{{ svn_username }}'
SVN_PASSWORD='{{ svn_password }}'
GIT_USERNAME='{{ git_username }}'
GIT_PASSWORD='{{ git_password }}'
PROJECT_KEY='{{ project_key }}'

# Should we go ahead and call git svn clone here so we can loop over it? Each repo has to have everything else done to it so...
while IFS= read -r p
do
	# clear errors variable
	errors='None'
	log_result=''
	# return to working directory
	cd $INSTALL_DIR/repos

	# read svn repo name for repo_list
	reponame=$(echo "$p" | rev | cut -d '/' -f 1 | rev)

	# clone the svn repo
	# for cloning with credentials try:
	# echo $SVN_PASSWORD | git svn clone --username $SVN_USERNAME --authors-file="" --stdlayout --prefix="origin/" $p -s $reponame >> $LOG_DIRECTORY 2>&1
	echo $SVN_PASSWORD | git svn clone --username $SVN_USERNAME --authors-file="authors" --stdlayout --prefix="origin/" $p -s $reponame >> $LOG_DIRECTORY/$reponame.log 2>&1
	log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
	if [ -z "$log_result" ]; then
		errors='None'
	else
		errors=$log_result
		curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
	fi

	# Navigate to the git svn cloned directory
	if [ "$errors" != "$log_result" ]; then
		cd $INSTALL_DIR/repos/$reponame
	fi

# Loop over all peg revisions and remove them. Git has no comparible feature. NOTE: Make sure these can be erased.
	if [ "$errors" != "$log_result" ]; then
		for r in $(git for-each-ref --format='%(refname:short)' | grep @);
		do 
			git branch -D -r $r >> $LOG_DIRECTORY/$reponame.log 2>&1
		done
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi

# Loop over all branches beginning with tags. Tag them and remove the remote branches.
	if [ "$errors" != "$log_result" ]; then
		for t in $(git for-each-ref --format='%(refname:short)' refs/remotes/origin/tags);
		do 
			git tag ${t##o*/} >> $LOG_DIRECTORY/$reponame.log 2>&1
			git branch -D -r $t >> $LOG_DIRECTORY/$reponame.log 2>&1
		done
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi

# Loop over all remaining branches. Branch them and remove the remote branches.
	if [ "$errors" != "$log_result" ]; then
		for b in $(git for-each-ref --format='%(refname:short)' refs/remotes/origin);
		do 
			git branch ${b##o*/} refs/remotes/$b >> $LOG_DIRECTORY/$reponame.log 2>&1
			git branch -D -r $b >> $LOG_DIRECTORY/$reponame.log 2>&1
		done
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi

# Remove the trunk branch. It is already now in git as the master branch.
	if [ "$errors" != "$log_result" ]; then
		git branch -d trunk >> $LOG_DIRECTORY/$reponame.log 2>&1
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi
	
# Create the Bitbucket project for repositories to be created in. NOTE: If we create a project for all converted repos to live in, move this outside while loop.
# To create a project: json needs name, key, description.
	#if [ -z "$errors" -ne "$log_result" ]; then
		#curl -u $GIT_USERNAME:$GIT_PASSWORD -X POST -d '{ "name": "$project_name", "key": "$PROJECT_KEY" }' -H "Content-Type: application/json" $GIT_REPO_DIR/rest/api/1.0/projects/ >> $LOG_DIRECTORY/$reponame.log 2>&1
		#log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep 'fatal:\|error:\|Bad' cut -d ' ' -f 1-4)
		#if [ -z "$log_result" ]; then
			#$errors="None"
		#else
			#$errors=$log_result
			#curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" $WEBPAGE_URL 2>&1 /dev/null
		#fi
	#fi
	
# Create the Bitbucket repository to push converted svn repo to.
# To create repo: json needs name, has_wiki, is_private, and project with sub-info key.
	if [ "$errors" != "$log_result" ]; then
		curl -u $GIT_USERNAME:$GIT_PASSWORD -X POST -d '{ "name": '\""$reponame\""', "has_wiki": false, "is_private": true, "project": {"key": '\""$PROJECT_KEY\""'} }' -H "Content-Type: application/json" --basic $GIT_REPO_DIR/rest/api/1.0/projects/$PROJECT_KEY/repos >> $LOG_DIRECTORY/$reponame.log 2>&1
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi

# Add the remote git repository as a remote. NOTE: We need to figure out how we will be authenticating with git here. SSH or user/pass over https?
	if [ "$errors" != "$log_result" ]; then
		git remote add origin http://$GIT_USERNAME:$GIT_PASSWORD@$GIT_REPO_DIR/scm/$PROJECT_KEY/$reponame.git >> $LOG_DIRECTORY/$reponame.log 2>&1
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi

#################################################
# to use credentials on git pushes use:
# git push http://$GIT_USERNAME:$GIT_PASSWORD@$GIT_REPO_DIR/$reponame.git --tags  >> $LOG_DIRECTORY 2>&1
# Probably have to go ahead and push the tags up. Git module for ansible is EXTREMELY limiting...
	if [ "$errors" != "$log_result" ]; then
		git push origin --tags >> $LOG_DIRECTORY/$reponame.log 2>&1
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi

# And if we should be all inclusive and just keep all git related functionality in this script, push all changes. Tags are NOT included during a push all.
	if [ "$errors" != "$log_result" ]; then
		git push origin --all >> $LOG_DIRECTORY/$reponame.log 2>&1
		log_result=$(cat $LOG_DIRECTORY/$reponame.log | grep "fatal:\|error:\|Bad" | cut -c-50)
		if [ -z "$log_result" ]; then
			errors='None'
			curl --data "token=$TOKEN&status=success&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		else
			errors=$log_result
			curl --data "token=$TOKEN&status=failed&ip_address=$IP_ADDRESS&repo_name=$reponame&error_msg=$errors" -X POST $WEBPAGE_URL >> $LOG_DIRECTORY/curl.log 2>&1
		fi
	fi

# If the push was a success, should we clean up the git repository since it now lives in Bitbucket and is not needed locally?
	

	# finally, add repo results to main log file
	echo "-----------------------------------------------------" >> $LOG_DIRECTORY/main_log.log
	echo "$reponame" >> $LOG_DIRECTORY/main_log.log
	echo "-----------------------------------------------------" >> $LOG_DIRECTORY/main_log.log
	echo $(cat $LOG_DIRECTORY/$reponame.log) >> $LOG_DIRECTORY/main_log.log

done < $INSTALL_DIR/repo_list
